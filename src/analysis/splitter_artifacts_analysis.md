# Анализ проблемы с артефактами при перемещении горизонтального разделителя

## Описание проблемы

В приложении Python Calculator наблюдаются визуальные артефакты (искажения, мерцание, остаточные изображения) при перемещении горизонтального разделителя между областью редактора кода и областью вывода результатов.

## Архитектура разделителя

### Реализация разделителя
- Используется `tk.PanedWindow` из стандартной библиотеки tkinter
- Разделитель имеет вертикальную ориентацию (`orient=tk.VERTICAL`)
- Ширина разделителя: `sashwidth=8`
- Стиль разделителя: `sashrelief=tk.RAISED`

### Компоненты в панелях
- **Верхняя панель**: `PythonEditor` с `scrolledtext.ScrolledText` и подсветкой синтаксиса
- **Нижняя панель**: `MarkdownOutputDisplay` с `ctk.CTkTextbox` и цветовым оформлением

## Выявленные причины артефактов

### 1. Конфликты цветовой схемы между tkinter и CustomTkinter

**Код проблемы:**
```python
bg=ctk.ThemeManager.theme["CTkFrame"]["fg_color"][1] if ctk.get_appearance_mode() == "Dark" else ctk.ThemeManager.theme["CTkFrame"]["fg_color"][0]
```

**Проблема:**
- `tk.PanedWindow` - стандартный виджет tkinter, не поддерживающий динамическую смену цветовой схемы CustomTkinter
- Во время перетаскивания возникают визуальные конфликты между цветами разделителя и дочерних компонентов
- Цвет фона разделителя не синхронизируется с темой в реальном времени

### 2. Частые вызовы обработчика перемещения

**Код привязки событий:**
```python
self.splitter.bind('<ButtonRelease-1>', self._on_splitter_moved)
self.splitter.bind('<B1-Motion>', self._on_splitter_moved)
```

**Проблема:**
- Метод `_on_splitter_moved` вызывается при каждом пикселе движения мыши
- Это приводит к частым операциям ввода-вывода для сохранения позиции
- Многократные вызовы `self.splitter.sash_coord(0)` и `self.splitter.winfo_height()`
- Потенциальные конфликты при одновременном доступе к геометрии виджетов

### 3. Проблемы с геометрией компонентов во время перетаскивания

**Сложные компоненты в панелях:**
- Верхняя панель: `scrolledtext.ScrolledText` с подсветкой синтаксиса (ColorDelegator, Percolator)
- Нижняя панель: `ctk.CTkTextbox` с множеством цветовых тегов и markdown-парсингом

**Проблема:**
- Во время перетаскивания компоненты не успевают перерисовываться корректно
- Создаются временные визуальные артефакты из-за частичного обновления содержимого
- Конфликты между процессом перетаскивания и перерисовкой содержимого

### 4. Отсутствие оптимизации для режима реального времени

**Текущая реализация:**
- Сохранение позиции происходит синхронно при каждом движении
- Нет буферизации или отложенных обновлений
- Геометрия проверяется немедленно во время перетаскивания

**Проблема:**
- Перетаскивание разделителя блокируется операциями сохранения
- Частые системные вызовы во время визуальной операции
- Нет разделения между логикой перетаскивания и логикой сохранения

### 5. Проблемы с композитной отрисовкой в Windows

**Системные особенности:**
- Windows использует композитную отрисовку окон
- Быстрое изменение размеров панелей создает дополнительные артефакты
- Конфликты между аппаратным ускорением и программной отрисовкой

## Предлагаемые решения

### 1. [x] Оптимизация цветовой схемы
```python
# Использовать статический цвет или добавить обработчик изменения темы
self.splitter.configure(bg="#2b2b2b" if is_dark else "#e5e5e5")
ctk.AppearanceModeTracker.add(self._update_splitter_colors)
```

### 2. [x] Улучшение обработки событий
```python
# Сохранять позицию только при отпускании кнопки
self.splitter.bind('<ButtonRelease-1>', self._on_splitter_moved)
# Убрать привязку <B1-Motion> для сохранения
```

### 3. [ ] Добавление throttling для операций сохранения
```python
def _on_splitter_moved(self, event=None):
    # Использовать after() для отложенного сохранения
    if hasattr(self, '_save_timer'):
        self.root.after_cancel(self._save_timer)
    self._save_timer = self.root.after(100, self._save_splitter_position)
```

### 4. [ ] Двойная буферизация содержимого
```python
def _on_splitter_drag_start(self, event):
    # Временно отключить обновление содержимого
    self.editor.freeze_updates()
    self.output.freeze_updates()

def _on_splitter_drag_end(self, event):
    # Восстановить обновление содержимого
    self.editor.unfreeze_updates()
    self.output.unfreeze_updates()
```

### 5. [ ] Оптимизация геометрии
- Использовать более эффективные методы проверки размеров
- Добавить защиту от рекурсивных вызовов
- Кэшировать результаты измерений

## Приоритетные действия

1. [x] **Высокий приоритет**: Убрать сохранение позиции во время движения мыши
2. [x] **Средний приоритет**: Оптимизировать цветовую схему разделителя
3. [ ] **Средний приоритет**: Добавить throttling для операций сохранения
4. [ ] **Низкий приоритет**: Реализовать двойную буферизацию содержимого

## Файлы для анализа
- `app.py` - основная логика разделителя (строки 102-134, 474-486)
- `components/python_editor.py` - реализация редактора кода
- `components/output_markdown.py` - реализация области вывода

## Тестирование решения
1. [x] Запустить приложение и проверить перемещение разделителя
2. [x] Проверить в обеих темах (светлая/темная)
3. [ ] Проверить на разных размерах окна
4. [ ] Проверить производительность при больших объемах текста
